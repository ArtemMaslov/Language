------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------

Сделать:

	- Нарисовать кружочек в видео памяти.

	- frontEnd
	{	
		Констукция if-else.
		{
			if () {}
			else if () {}
			else if () {}
			else {}
		}
		
		a++, b--, ++a, --b.
		+=, -=, /=, *=.
		
		Power ^.
		
		Глобальные переменные.
		Побитовые операции ~, |, &, xor.
		
	}

	- AST
	{
		Power ^.
		Глобальные переменные.
		Побитовые операции ~, |, &, xor.
	}

	- backEnd
	{
		Power ^.
		Глобальные переменные.
		Побитовые операции ~, |, &, xor.
	}
	
	- Backend. SoftCpu. Intrinsic functions. Есть лишняя пара "pop ax", "push ax".
	
	- BackEnd. SoftCpu. В main в начале и конце есть не нужные push и pop регистров bx и cx.
	
	- Backend. SoftCpu. Заменить структуру IdentifierTable на более легковесную. Там, например, не нужна ExtHeap и имена переменных, достаточно их Id.
	  Frontend. Убрать лишние поля из таблицы идентификаторов.
	
	- FunctCallParam. FunctDefParam. Возможно имеет смысл разделить параметры функции на две структуры.
	
	- AST graphic dump. Форма узлов. Цвет узлов. Цвет стрелочек. Форма стрелочек? Направление выхода стрелочек (сейчас не понятно у ifNode, кто Condition, кто True block, кто False block).

	-? Identifier. Оптимизировать поиск имени по id до O(1). Сейчас id есть индекс записи в таблице идентификаторов.
	
	- Lexer изменить идеологию. Token* tokens и IdentifierTable - это выходные параметры, поэтому их не нужно очищать.
	  Скрыть конструктор и деструктор. Оставить только функцию лексического анализа файла.
	  
	- Parser изменить идеологию. Аналогично, структура Parser - для внутренних нужд. 
	  Оставить видимой только одну функцию - синтаксический анализ файла.
	
	- Все деструкторы изменить void. Они должны безошибочно очищать любые данные, в том числе nullptr.
	
	- enum -> enum class.
	
	- Отрефакторить старые модули по новым стандартам.
	
	- Комментарии к коду, структурам.
	
	- Документация к функциям.
	
	- Expression parsing. В момент создания дерева мат. выражения, в случае ошибки не будет освобождена память занятая ExtArray в FunctCallNode!

Пометки:
	* Идентификатор это 'a'-'z', 'A'-'Z', '_'.

	* Отрицательные числа читаются как две лексемы: унарный оператор "-" и число "12345".
	
	* Регистры bx, cx зарезервированы под создание стека фреймов вызовов функций.
	
	* Функция возвращает значение черех ax. 
	
------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------
	
				!------ Название версии ------!
""
в 0.0.0.3
	
Сделано:

------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------

Задание нарисовать кружочек в видео-памяти. Исправление ошибки лексического анализатора.
"circle task. lexer bug fix"
в 0.0.0.2
	
Сделано:
	+ SoftCpu Compiler. Добавлены intrinsic-функции:
	{
		+ set_ram
		
		+ get_ram
		
		+ dsp
		
		+ int
	}
	
	+ Lexer. 
	{
		+ Добавлена возможность писать '_' в идентификаторе.
		
		+ Исправлена ошибка из-за которой идентификаторы 'x123456' и 'x123' считались одинаковыми.
	}
	
	+ CHECK_STATUS. В некоторых файлах условие "if (status != ProgramStatus::Ok) return status;" заменено на "assert(status == ProgramStatus::Ok);".
	
	+ circle.lng - рисует кружочек в консоль.	
	
------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------

Первая работающая версия. Базовый функционал.
"First prototype"
в 0.0.0.1

Сделать:

	- Нарисовать кружочек в видео памяти.

	- frontEnd
	{	
		Констукция if-else.
		{
			if () {}
			else if () {}
			else if () {}
			else {}
		}
		
		a++, b--, ++a, --b.
		+=, -=, /=, *=.
		
		Power ^.
		
		Глобальные переменные.
		Побитовые операции ~, |, &, xor.
		
	}

	- AST
	{
		Power ^.
		Глобальные переменные.
		Побитовые операции ~, |, &, xor.
	}

	- backEnd
	{
		Power ^.
		Глобальные переменные.
		Побитовые операции ~, |, &, xor.
	}
	
	- BackEnd. В main в начале и конце есть не нужные push и pop регистров bx и cx.
	
	- Backend. Заменить структуру IdentifierTable на более легковесную. Там, например, не нужна ExtHeap и имена переменных, достаточно их Id.
	  Frontend. Убрать лишние поля из таблицы идентификаторов.
	
	- FunctCallParam. FunctDefParam. Возможно имеет смысл разделить параметры функции на две структуры.
	
	- AST graphic dump. Форма узлов. Цвет узлов. Цвет стрелочек. Форма стрелочек? Направление выхода стрелочек (сейчас не понятно у ifNode, кто Condition, кто True block, кто False block).

	-? Identifier. Оптимизировать поиск имени по id до O(1). Сейчас id есть индекс записи в таблице идентификаторов.
	
	- Lexer изменить идеологию. Token* tokens и IdentifierTable - это выходные параметры, поэтому их не нужно очищать.
	  Скрыть конструктор и деструктор. Оставить только функцию лексического анализа файла.
	  
	- Parser изменить идеологию. Аналогично, структура Parser - для внутренних нужд. 
	  Оставить видимой только одну функцию - синтаксический анализ файла.
	
	- Все деструкторы изменить void. Они должны безошибочно очищать любые данные, в том числе nullptr.
	
	- enum -> enum class.
	
	- Отрефакторить старые модули по новым стандартам.
	
	- Комментарии к коду, структурам.
	
	- Документация к функциям.
	
	- Expression parsing. В момент создания дерева мат. выражения, в случае ошибки не будет освобождена память занятая ExtArray в FunctCallNode!
	
Сделано:
	+ Лексический анализатор. Разбиение текста на лексемы. Идентификаторам (функции + переменные) присваивается уникальное числовое значение. Тесты.

	+ Синтаксический анализатор. Создание абстрактного синтаксического дерева. Тесты.
	
	+ Абстрактное синтаксическое дерево. Функции для его построения.
		
	+ Компилятор для программного процессора. Тестовые программы: квадратное уравнение, факториал (цикл), факториал (рекурсия). !Кружочек не работает!
	
	+ Реализованы возможности языка:
	{
		+ Создание переменных локальных внутри функции.
		
		+ Рекурсивный вызов функций. Функция может возвращать значение.
		
		+ Выполнение программы начинается с main().
		
		+ if () {} else {}.
		
		+ while () {}.
		
		+ in.
		
		+ out.
		
		+ Математические выражения: '+', '-', '*', '/', '()', '||', '&&', '!', '+,- унарный', '>', '<', '>=', '<=', '==', '!=', 'num', 'var', 'functCall'.
		
		+ ret.
	}
	
Пометки:
	* Отрицательные числа читаются как две лексемы: унарный оператор "-" и число "12345".
	
	* Регистры bx, cx зарезервированы под создание стека фреймов вызовов функций.
	
	* Функция возвращает значение черех ax. 

------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------

1) AST/_aux_nodes.cpp - используется перегрузка AstCreateInstructionNode и AstCreateConstrNode. Насколько это хорошо, если используется ~"C"?

2) AST/_expr_nodes.cpp - AstCreateExpressionNode(AST* ast, double number). Значение number передаётся как указатель. 
   Оставить так или сделать копию функции (CopyPaste)?

3) enum class или enum?

4) Названия приватных файлов начинаются с _маленькой_буквы_и_нижнего_подчеркивания.
   
   Идея: не создавать для приватных файлов .h, а #include "*.cpp"? Тогда static функции не будут видны при линковке?

5) Назначенные инициализаторы С++20 или лучше держать стандарт версии С++14?

   union {int Int; enum vals} - инициализация. Нормально ли решение добавить в начало Int.
   
   Инициализация структур:
   
			struct A
			{
				int a;
				double b;
				char* c;
			}
		
		- назначенными инициализаторами:
		
			A = {.a = 10, .b = 3.14, .c = "str"};
		
		- Через функцию:
		
			A InitA(int a, double b, char* c)
			{
				struct A = {};
				A.a = a;
				A.b = b;
				A.c = c;
				
				return A;
			}
			
		- По порядку полей C-style:
		
			A = {10, 3.14, "str"};
			
   Изменение порядка полей в структуре - насколько часто это бывает, что тогда делать с инициализацией?

6) UnitTest'ы держать в папке с модулем или совсем отдельной:

	a)
   root/
		Parser/
			Parser.cpp
			Parser.h
			ParserUnitTests.cpp
			ParserUnitTests.h
			
		Other modules/
			...
	
	b)
	root/
		Parser/
			Parser.cpp
			Parser.h
		
		UnitTest/
			ParserUnitTests.cpp
			ParserUnitTests.h
			
			OtherModulesUnitTests.cpp
			OtherModulesUnitTests.h
			
		Other modules/
			...

7) Почему компилятор не оптимизирует вторую функцию так, что соптимизированные 1 и 2 функции будут совпадать?
   При этом он inline-ит и первую и вторую функции в место вызова и там уже код совпадает.
   Опции: Release \O2.

SkipSpaceSymbols1(const char** buffer)
{
	assert(buffer);
	
	const char* _buf = *buffer;
	while (*_buf == ' ' || *_buf == '\n' || *_buf == '\t')
		_buf++;
	
	*buffer = _buf;
}

SkipSpaceSymbols2(const char** buffer)
{
	assert(buffer);

	while (**buffer == ' ' || **buffer == '\n' || **buffer == '\t')
		(*buffer)++;
}

; Function compile flags: /Ogtpy
; File D:\C++\SoftProcessor\Assembler\Assembler.cpp
;	COMDAT ?SkipSpaceSymbols@@YAXPEAPEBD@Z
_TEXT	SEGMENT
buffer$ = 8
?SkipSpaceSymbols@@YAXPEAPEBD@Z PROC			; SkipSpaceSymbols, COMDAT

; 99   : 	assert(buffer);
; 100  : 
; 101  : 	const char* _buffer = *buffer;

	mov	rdx, QWORD PTR [rcx]
$LL2@SkipSpaceS:

; 102  : 	while (*_buffer == ' ' || *_buffer == '\n' || *_buffer == '\t')

	movzx	eax, BYTE PTR [rdx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN4@SkipSpaceS
	sub	al, 9
	cmp	al, 1
	ja	SHORT $LN14@SkipSpaceS
$LN4@SkipSpaceS:

; 103  : 		_buffer++;

	inc	rdx
	jmp	SHORT $LL2@SkipSpaceS
$LN14@SkipSpaceS:

; 104  : 
; 105  : 	*buffer = _buffer;

	mov	QWORD PTR [rcx], rdx

; 106  : }

	ret	0
?SkipSpaceSymbols@@YAXPEAPEBD@Z ENDP			; SkipSpaceSymbols
_TEXT	ENDS

; Function compile flags: /Ogtpy
; File D:\C++\SoftProcessor\Assembler\Assembler.cpp
;	COMDAT ?SkipSpaceSymbols2@@YAXPEAPEBD@Z
_TEXT	SEGMENT
buffer$ = 8
?SkipSpaceSymbols2@@YAXPEAPEBD@Z PROC			; SkipSpaceSymbols2, COMDAT

; 109  : {

	npad	2
$LL2@SkipSpaceS:

; 110  : 	assert(buffer);
; 111  : 
; 112  : 	while (**buffer == ' ' || **buffer == '\n' || **buffer == '\t')

	mov	rdx, QWORD PTR [rcx]
	movzx	eax, BYTE PTR [rdx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN4@SkipSpaceS
	sub	al, 9
	cmp	al, 1
	ja	SHORT $LN3@SkipSpaceS
$LN4@SkipSpaceS:

; 113  : 		(*buffer)++;

	lea	rax, QWORD PTR [rdx+1]
	mov	QWORD PTR [rcx], rax
	jmp	SHORT $LL2@SkipSpaceS
$LN3@SkipSpaceS:

; 114  : }

	ret	0
?SkipSpaceSymbols2@@YAXPEAPEBD@Z ENDP			; SkipSpaceSymbols2
_TEXT	ENDS


8) Бесит стиль написания кода через строчку. "static ExpressionNode* ParseUnaryOperator(Parser* parser)"

case OperatorType::Subtraction:

	ExpressionNode* operandNode = ParseParentheses(parser);

	if (!operandNode)
	{
		return nullptr;
	}

	parser->CurrentToken += 1;

	UnaryOperatorNode* unOperNode = AstCreateUnaryOperatorNode(ast, OperatorType::Subtraction, operandNode);

	if (!unOperNode)
	{
		return nullptr;
	}

	ExpressionNode* exprNode = AstCreateExpressionNode(ast, unOperNode);

	if (!exprNode)
	{
		return nullptr;
	}

	return exprNode;
	
9) SoftProcessor. CompileCompareOperator();

	fprintf(comp->File, CompCompareFormat,
			jmpType,
			labelName, comp->LabelIndex,
			labelName, comp->LabelIndex,
			labelName, comp->LabelIndex,
			labelName, comp->LabelIndex);
			
10) Почему не получается inline AsmCreateArgImm(). x86. 

11) Перенести несколько проектов git в общий репозиторий с сохранением истории коммитов.